<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>방덱 목록 뷰어</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📝</text></svg>">
    <style>
    .autocomplete-list {
        position: absolute;
        left: 0;
        top: 38px;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 4px;
        z-index: 9999;
        max-height: 180px;
        overflow-y: auto;
        min-width: 200px;
        width: calc(100% - 120px);
        margin-top: 0;
        display: none;
    }
    .autocomplete-item {
        padding: 6px 12px;
        cursor: pointer;
    }
    .autocomplete-item.selected {
        background: #e0e0e0;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="title-container">
            <h1 class="main-title">방덱 목록 뷰어</h1>
        </div>
        <!-- 불러오기 및 검색창 추가 -->
        <div class="viewer-top-controls" style="display: flex; gap: 16px; align-items: center; margin-bottom: 20px; position:relative;">
            <button id="memoSearchToggleBtn" class="action-btn" style="margin-right:8px;">메모검색</button>
            <input type="text" id="viewerSearchInput" placeholder="목록 검색" style="flex:1; min-width:200px; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px;">
            <div id="autocompleteList" class="autocomplete-list"></div>
            <button id="viewerSearchBtn" class="action-btn" style="background:#4CAF50;color:white;">검색</button>
            <!-- 메모 검색 드롭다운 -->
            <div id="memoSearchDropdown" style="display:none; position:absolute; left:0; top:0; width:100%; background:#fff; z-index:10000; box-shadow:0 2px 8px rgba(0,0,0,0.08); padding:16px 12px 12px 12px; border-radius:8px;">
                <div style="display:flex; gap:8px; align-items:center;">
                    <input type="text" id="memoSearchInput" placeholder="메모 내용 검색" style="flex:1; min-width:180px; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px;">
                    <button id="memoSearchBtn" class="action-btn" style="background:#2196F3;color:white;">검색</button>
                    <button id="memoSearchCloseBtn" class="action-btn" style="background:#aaa;color:white;">닫기</button>
                </div>
            </div>
        </div>
        <!-- 검색 및 추가 섹션 (기능 제한 적용) -->
        <div class="search-section">
            <div class="input-group">
                <input type="text" id="searchInput" placeholder="방덱 검색" style="display:none;">
                <!-- 추가 버튼은 숨김 -->
                <button id="addListBtn" class="add-btn" style="display:none;">추가</button>
            </div>
            <div id="searchResults" class="search-results"></div>
        </div>
        <!-- 통계 섹션 -->
        <div class="stats-section">
            <div class="category-buttons">
                <button class="category-btn" id="cat-all" data-filter-type="all">전체보기</button>
                <button class="category-btn" id="cat-4deck" data-filter-type="4방덱">4방덱 (<span id="stat-4">0</span>)</button>
                <button class="category-btn" id="cat-5deck" data-filter-type="5방덱">5방덱 (<span id="stat-5">0</span>)</button>
                <button class="category-btn" id="cat-other" data-filter-type="기타">기타 (<span id="stat-other">0</span>)</button>
            </div>
        </div>
        <!-- 임시 목록 섹션 -->
        <div class="temporary-section">
            <h2>임시 목록</h2>
            <button id="moveToOriginalBtn" class="action-btn" style="margin-bottom:10px;">기존 목록으로 되돌리기</button>
            <div id="temporaryLists" class="lists-container"></div>
        </div>
        <!-- 기존 목록 섹션 -->
        <div class="existing-section">
            <h2>기존 목록</h2>
            <div id="lists" class="lists-container"></div>
            <div id="paginationControls" class="pagination-controls"></div>
        </div>
        <!-- 클립보드 설정 (숨김 처리) -->
        <div class="clipboard-settings" style="display:none;">
            <div class="clipboard-header">
                <h3>클립보드 설정</h3>
                <button class="toggle-clipboard-btn">접기</button>
            </div>
            <div class="clipboard-content">
                <p class="clipboard-description">자주 사용하는 메모를 저장하고 단축키(Alt + 숫자)로 빠르게 입력할 수 있습니다.</p>
                <div class="clipboard-items">
                    <!-- 클립보드 아이템들은 JavaScript로 동적 생성됩니다 -->
                </div>
            </div>
        </div>
    </div>
    <!-- JSON 불러오기 버튼을 페이지 맨 아래로 이동 -->
    <div class="json-import-bottom" style="display: flex; justify-content: flex-end; margin: 30px 0 10px 0;">
        <button id="importJsonBtn" class="action-btn">JSON 불러오기</button>
        <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
    </div>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/11.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.0/firebase-auth-compat.js"></script>
    <!-- 메인 스크립트 -->
    <script src="script.js"></script>
    <script>
        // viewer.html에서 기능 제한 적용 및 불러오기/검색 기능 추가
        document.addEventListener('DOMContentLoaded', function() {
            // 로그인 관련 UI/기능 제거: loginStatus, handleLoginStatus 등
            const loginStatus = document.getElementById('loginStatus');
            if (loginStatus) loginStatus.style.display = 'none';
            window.handleLoginStatus = undefined;

            // 1. 목록 추가 버튼 숨김(이미 숨김)
            const addListBtn = document.getElementById('addListBtn');
            if (addListBtn) addListBtn.style.display = 'none';

            // 2. 클립보드 영역 숨김(이미 style로 처리)
            const clipboardSettings = document.querySelector('.clipboard-settings');
            if (clipboardSettings) clipboardSettings.style.display = 'none';

            // 3. 목록/메모 추가, 수정, 삭제 버튼 숨기기 및 입력창 비활성화
            const observer = new MutationObserver(() => {
                // 목록 관련 버튼 숨김 (실제 HTML 클래스명까지 모두 포함)
                document.querySelectorAll('.add-list-btn, .edit-list-btn, .delete-list-btn, .save-list-btn, .cancel-list-btn, button[title="목록 편집"], button[title="목록 삭제"], button[title="편집"], button[title="삭제"], button.edit-list-btn, button.delete-list-btn, button.edit-btn, button.delete-btn').forEach(btn => btn.style.display = 'none');
                // 메모 관련 버튼 숨김 (실제 HTML 클래스명까지 모두 포함)
                document.querySelectorAll('.add-memo-btn, .edit-memo-btn, .delete-memo-btn, .save-memo-btn, .cancel-memo-btn, button[title="메모 편집"], button[title="메모 삭제"], button[title="수정"], button[title="삭제"], button.edit-memo-btn, button.delete-memo-btn').forEach(btn => btn.style.display = 'none');
                // 메모 입력창 비활성화
                document.querySelectorAll('.memo-input, .list-title-input').forEach(input => input.setAttribute('readonly', 'readonly'));
                // 메모 승패 조작 버튼 숨김
                document.querySelectorAll('.win-btn, .loss-btn, .counter-btn').forEach(btn => btn.style.display = 'none');
            });
            observer.observe(document.body, { childList: true, subtree: true });

            // 페이지 로딩 시에도 한 번 강제적으로 숨김 처리
            setTimeout(() => {
                document.querySelectorAll('.add-list-btn, .edit-list-btn, .delete-list-btn, .save-list-btn, .cancel-list-btn, button[title="목록 편집"], button[title="목록 삭제"], button[title="편집"], button[title="삭제"], button.edit-list-btn, button.delete-list-btn, button.edit-btn, button.delete-btn').forEach(btn => btn.style.display = 'none');
                document.querySelectorAll('.add-memo-btn, .edit-memo-btn, .delete-memo-btn, .save-memo-btn, .cancel-memo-btn, button[title="메모 편집"], button[title="메모 삭제"], button[title="수정"], button[title="삭제"], button.edit-memo-btn, button.delete-memo-btn').forEach(btn => btn.style.display = 'none');
            }, 300);

            // 페이지 로딩 시 목록 자동 불러오기
            if (typeof loadLists === 'function') {
                loadLists();
            } else if (window.loadLists) {
                window.loadLists();
            }

            // 불러오기 버튼 이벤트
            const importBtn = document.getElementById('importJsonBtn');
            const fileInput = document.getElementById('jsonFileInput');
            if(importBtn && fileInput) {
                importBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(ev) {
                            try {
                                const data = JSON.parse(ev.target.result);
                                if (typeof processImportedJson === 'function') {
                                    processImportedJson(data);
                                } else if (window.processImportedJson) {
                                    window.processImportedJson(data);
                                }
                            } catch (err) {
                                // alert('JSON 파일 형식이 올바르지 않습니다.'); // 알림 제거
                            }
                        };
                        reader.readAsText(e.target.files[0]);
                    }
                });
            }

            // 검색 버튼 이벤트(검색어 포함 목록을 임시 목록으로 이동)
            const viewerSearchBtn = document.getElementById('viewerSearchBtn');
            const viewerSearchInput = document.getElementById('viewerSearchInput');
            if(viewerSearchBtn && viewerSearchInput) {
                viewerSearchBtn.addEventListener('click', function() {
                    const query = viewerSearchInput.value.trim();
                    if (!query) return;
                    // 공백 기준 단어 분리
                    const keywords = query.split(/\s+/).filter(Boolean);
                    if (keywords.length === 0) return;
                    // 기존 목록 중 모든 키워드를 포함하는 목록만 찾음
                    const matched = lists.filter(list =>
                        keywords.every(word => list.title && list.title.includes(word))
                    );
                    // 기존 임시 목록에 이미 있는 id는 중복 추가하지 않음
                    const tempIds = new Set(temporaryLists.map(l => l.id));
                    matched.forEach(list => {
                        if (!tempIds.has(list.id)) {
                            temporaryLists.push(JSON.parse(JSON.stringify(list)));
                        }
                    });
                    // 임시 목록 렌더링 및 저장
                    renderTemporaryLists();
                    saveTemporaryLists();
                });
                // 엔터 키로도 검색 동작
                viewerSearchInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        viewerSearchBtn.click();
                    }
                });
            }

            // 임시 목록을 기존 목록으로 되돌리는 버튼 기능
            const moveToOriginalBtn = document.getElementById('moveToOriginalBtn');
            if (moveToOriginalBtn) {
                moveToOriginalBtn.addEventListener('click', function() {
                    if (!Array.isArray(temporaryLists) || temporaryLists.length === 0) return;
                    // 임시 목록의 항목을 기존 목록에 중복 없이 추가
                    const listIds = new Set(lists.map(l => l.id));
                    temporaryLists.forEach(item => {
                        if (!listIds.has(item.id)) {
                            lists.push(JSON.parse(JSON.stringify(item)));
                        }
                    });
                    // 임시 목록 비우기
                    temporaryLists = [];
                    renderLists();
                    renderTemporaryLists();
                    saveLists();
                    saveTemporaryLists();
                });
            }

            // 추천단어 자동완성 기능
            const autocompleteList = document.getElementById('autocompleteList');
            let autocompleteWords = [];
            let filteredWords = [];
            let selectedIndex = -1;

            // 추천단어 후보 추출 (초기화)
            function extractWordsFromLists() {
                const wordSet = new Set();
                (lists || []).forEach(list => {
                    if (list.title) {
                        list.title.split(/\s+/).forEach(word => {
                            if (word.length > 1) wordSet.add(word);
                        });
                    }
                });
                autocompleteWords = Array.from(wordSet);
            }

            // 자동완성 리스트 렌더링
            function renderAutocompleteList(inputValue) {
                if (!inputValue) {
                    autocompleteList.style.display = 'none';
                    autocompleteList.innerHTML = '';
                    return;
                }
                // 현재 입력 중인 마지막 단어만 추출
                const parts = inputValue.split(/\s+/);
                const lastWord = parts[parts.length - 1];
                filteredWords = autocompleteWords.filter(w => w.includes(lastWord) && w !== lastWord);
                if (filteredWords.length === 0) {
                    autocompleteList.style.display = 'none';
                    autocompleteList.innerHTML = '';
                    return;
                }
                // 항상 첫 번째 단어가 자동 선택되도록
                selectedIndex = 0;
                autocompleteList.innerHTML = filteredWords.map((w, i) => `<div class=\"autocomplete-item${i===selectedIndex?' selected':''}\" data-index=\"${i}\">${w}</div>`).join('');
                autocompleteList.style.display = 'block';
            }

            // 자동완성 선택 처리
            function selectAutocomplete(idx) {
                selectedIndex = idx;
                renderAutocompleteList(viewerSearchInput.value);
            }

            // 자동완성 단어 삽입
            function insertAutocompleteWord(word, addSpace = false) {
                const parts = viewerSearchInput.value.split(/\s+/);
                parts[parts.length - 1] = word;
                let newValue = parts.join(' ');
                if (addSpace) newValue += ' ';
                viewerSearchInput.value = newValue;
                autocompleteList.style.display = 'none';
                selectedIndex = -1;
            }

            // 입력 이벤트
            viewerSearchInput.addEventListener('input', function(e) {
                extractWordsFromLists();
                selectedIndex = -1;
                renderAutocompleteList(this.value);
            });

            // 키보드 이벤트
            viewerSearchInput.addEventListener('keydown', function(e) {
                if (autocompleteList.style.display === 'block') {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (selectedIndex < filteredWords.length - 1) selectAutocomplete(selectedIndex + 1);
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (selectedIndex > 0) selectAutocomplete(selectedIndex - 1);
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        if (selectedIndex >= 0 && filteredWords[selectedIndex]) {
                            insertAutocompleteWord(filteredWords[selectedIndex]);
                        }
                    } else if (e.key === ' ') {
                        if (selectedIndex >= 0 && filteredWords[selectedIndex]) {
                            e.preventDefault();
                            insertAutocompleteWord(filteredWords[selectedIndex], true);
                        }
                    } else if (e.key === 'Enter') {
                        autocompleteList.style.display = 'none';
                        selectedIndex = -1;
                    }
                }
            });

            // 마우스 클릭으로 선택
            autocompleteList.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('autocomplete-item')) {
                    const idx = parseInt(e.target.getAttribute('data-index'));
                    if (!isNaN(idx)) {
                        insertAutocompleteWord(filteredWords[idx]);
                    }
                }
            });

            // 포커스 아웃 시 자동완성 닫기
            viewerSearchInput.addEventListener('blur', function() {
                setTimeout(() => {
                    autocompleteList.style.display = 'none';
                    selectedIndex = -1;
                }, 150);
            });

            // 메모검색 드롭다운 UI 토글
            const memoSearchToggleBtn = document.getElementById('memoSearchToggleBtn');
            const memoSearchDropdown = document.getElementById('memoSearchDropdown');
            const memoSearchInput = document.getElementById('memoSearchInput');
            const memoSearchBtn = document.getElementById('memoSearchBtn');
            const memoSearchCloseBtn = document.getElementById('memoSearchCloseBtn');
            if(memoSearchToggleBtn && memoSearchDropdown) {
                memoSearchToggleBtn.addEventListener('click', function() {
                    memoSearchDropdown.style.display = 'block';
                    memoSearchInput.value = '';
                    memoSearchInput.focus();
                });
            }
            if(memoSearchCloseBtn && memoSearchDropdown) {
                memoSearchCloseBtn.addEventListener('click', function() {
                    memoSearchDropdown.style.display = 'none';
                });
            }
            // 메모 검색 기능: 입력 후 버튼 클릭 시 해당 단어를 포함하는 메모가 있는 목록을 임시목록으로 이동
            if(memoSearchBtn && memoSearchInput) {
                memoSearchBtn.addEventListener('click', function() {
                    const query = memoSearchInput.value.trim();
                    if (!query) return;
                    // 검색어를 공백 기준 단어로 분리
                    const keywords = query.split(/\s+/).filter(Boolean);
                    // 기존 목록 중 메모 내용이 모든 키워드를 포함하는 목록만 추출
                    const matched = lists.filter(list =>
                        Array.isArray(list.memos) && list.memos.some(memo => {
                            if (!memo.text) return false;
                            // 메모 내용을 공백 기준 단어로 분리
                            const memoWords = memo.text.split(/\s+/);
                            // 모든 검색어가 메모 단어에 포함되어야 함
                            return keywords.every(kw => memoWords.some(mw => mw.includes(kw)));
                        })
                    );
                    // 기존 임시 목록에 이미 있는 id는 중복 추가하지 않음
                    const tempIds = new Set(temporaryLists.map(l => l.id));
                    matched.forEach(list => {
                        if (!tempIds.has(list.id)) {
                            temporaryLists.push(JSON.parse(JSON.stringify(list)));
                        }
                    });
                    renderTemporaryLists();
                    saveTemporaryLists();
                    if (matched.length > 0) memoSearchDropdown.style.display = 'none';
                });
                // 엔터로도 검색 동작
                memoSearchInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        memoSearchBtn.click();
                    }
                });
            }
        });
    </script>
</body>
</html> 